% Appendix A

\chapter{Software Documentation} % Main appendix title
\centering \textit{The following is a list of the repositories of code used to visualize the simulations including descriptions of each script contained within. Additionally, we list and describe each function/method contained withing the scripts and the file structure for each data type used.} 
\newline
\newline
\label{Appendix-PreUnity} % For referencing this appendix elsewhere, use \ref{AppendixA}
\begin{itemize}
\item \textbf{FDSPreUnityTool}
\item[]
Converts the plot3D output from Fire Dynamic Simulator (FDS) into a more optimized data format to be visualized inside of unit. 
   \begin{itemize}
        \item \textbf{fds2ComplexGeom.py}
        \item[] Converts FDS input file into a JSON with tree location data and complex terrain information
        \item \textbf{fdsOutput2Unity.py}
        \item[] Converts plot3D data from FDS into binary data to be loaded into unity
        \item \textbf{fdsPathLines.py}
        \item[] Takes plot3D data and calculates the amount of turbulence (represented as Reynolds numbers) to identify regions of interest. Then calculates pathlines that will intersect with points sampled from these regions
        \item \textbf{main.py}
        \item[] Creates the proper file structure and ensures all functions save data into the proper location  
   \end{itemize}
\pagebreak

\item \textbf{FDS2UnityVR}
\item[] Visualizes the data from \textbf{FDSPreUnityTool} in an immersive VR environment using Unity's Real-Time Development Platform    
   \begin{itemize}
        \item \textbf{ConfigData.cs}
        \item[] Saves all information when transitioning from one scene to another 

        \item \textbf{hrrLoader.cs}
        \item[] Loads in a color mapped and animated fire particle engine in each voxel per timestep
        \item \textbf{MainMenu.cs}
        \item[] Verifies menu check boxes are selected and verifies fire and directory structure for input data
        \item \textbf{PauseMenu.cs}
        \item[] Checks pause button input and tracks time in pause menu to allow for accurate timesteps after pausing 
        \item \textbf{smokeLoader.cs}
        \item[] Loads in a color mapped and animated smoke particle engine in each voxel per timestep
        \item \textbf{smvReader.cs}
        \item[] Loads in and caches heat release rate and smoke density data while tracking the current timestep
        
        \item \textbf{tduController.cs}
        \item[] Uses calulations of thermal dosage from Parsons, Russell A., Butler, Bret. W., and Mell, William â€œRuddy" to visualize burn injury potential \cite{Parsons2014}
        \item \textbf{TerrainBuilder.cs}
        \item[] Loads a JSON of terrain data from fds2ComplexGeom.py \ref{PythonComplexGeom} and maps to a 3-D mesh with texturing
        \item \textbf{TreeLoader.cs}
\item[] Loads a JSON of tree data from  fds2ComplexGeom.py \ref{PythonComplexGeom} and maintains scale regardless of the size of the 3-D tree object        
        \item \textbf{WindStreams.cs}
        \item[] Loads in and caches pathline data from fdsPathLines.py \ref{PythonPathLines} to be visualized each timestep
        \end{itemize}
\end{itemize}
\pagebreak

\section{FDSPreUnityTool}
\subsection{fds2ComplexGeom.py}
Converts FDS input file into a JSON with tree location data and complex terrain information
\label{PythonComplexGeom}
\begin{itemize}
    \item \textbf{Class instantiation}
    \begin{itemize}    
    \item Parameters   
        \begin{itemize}
        \item\textbf{fds\_input\_location:} Complete path to FDS input file (.fds)
        \item \textbf{tree\_id:} Name of the tree label
        \item \textbf{non\_terrain\_obsts:} List of any obstacles that are not classified as terrain
        \end{itemize} 
    \end{itemize}
    
    \item \textbf{read\_in\_fds\_obst}
    \item[] Reads in FDS input file and generates a dictionary of dictionaries containing the elevation data for the terrain
    
    \item \textbf{read\_in\_tree\_locations}
    \item[] Reads in all the locations of trees in the FDS input file and parses other tree information
      
    \item \textbf{read\_in\_fds\_mesh}
    \item[]  Reads in FDS input file and parses the MESH information
    
    \item \textbf{complex\_geom}
    \item[] Reads in topographical information and formats it for a 3-D mesh
    \item \textbf{save\_to\_json}
    \item[] Saves all parsed data into a JSON file
                \item[] \textbf{JSON File Structure}   
                \begin{itemize}
                \item\textbf{meshData}
                    \begin{itemize}
                    \item\textbf{X\_MIN:} x value of the origin point of the mesh 
                    \item\textbf{Y\_MIN:} y value of the origin point of the mesh 
                    \item\textbf{Z\_MIN:} z value of the origin point of the mesh 
                    \item\textbf{X\_MAX:} x value of the opposite corner
                    \item\textbf{Y\_MAX:} y value of the opposite corner
                    \item\textbf{Z\_MAX:} z value of the opposite corner
                    \item\textbf{I:} number of cells in the x direction
                    \item\textbf{J:} number of cells in the y direction
                    \item\textbf{K:} number of cells in the z direction
                    \end{itemize}
                \item\textbf{verts} 
                \item[] List of all vertices of the topographical map
                \item\textbf{faces} 
                \item[] List of indices of vertices to form triangle faces (one indexed values)
                \item\textbf{treeList}
                    \begin{itemize}
                    \item\textbf{x:} x position
                    \item\textbf{y:} y position
                    \item\textbf{height:} Ground height at position x,y
                    \item\textbf{crownBaseHeight:} Height from ground level where tree crown begins
                    \item\textbf{crownRadius:} Radius of tree crown
                    \item\textbf{crownHeight:} Height of tree crown 
                    \end{itemize}
                \end{itemize} 
    \item \textbf{write\_hdf5}
    \item[] Saves all parsed data into a HDF5 file 
    \item[] \textbf{Note:} Reading in the complex geometry as a HDF5 file has not been implemented in to the current Unity project
                \item[] \textbf{HDF5 File Structure}   
                \begin{itemize}
                \item\textbf{meshData} Array of nine, 32-bit floats
                \item[] [X\_MIN,Y\_MIN, Z\_MIN, X\_MAX, Y\_MAX, Z\_MAX, I, J, K]
                    \begin{itemize}
                    \item\textbf{X\_MIN:} x value of the origin point of the mesh 
                    \item\textbf{Y\_MIN:} y value of the origin point of the mesh 
                    \item\textbf{Z\_MIN:} z value of the origin point of the mesh 
                    \item\textbf{X\_MAX:} x value of the opposite corner
                    \item\textbf{Y\_MAX:} y value of the opposite corner
                    \item\textbf{Z\_MAX:} z value of the opposite corner
                    \item\textbf{I:} number of cells in the x direction
                    \item\textbf{J:} number of cells in the y direction
                    \item\textbf{K:} number of cells in the z direction
                    \end{itemize}
                \item\textbf{verts} 
                \item[] List of all vertices of the topographical map
                \item\textbf{faces} 
                \item[] List of indices of vertices to form triangle faces (one indexed values)
                \item\textbf{treeList} 2-D array, Size: N (number of trees) by six
                \item[] [x, y, height, crownBaseHeight, crownRadius, crownHeight]
                    \begin{itemize}
                    \item\textbf{x:} x position
                    \item\textbf{y:} y position
                    \item\textbf{height:} Ground height at position x,y
                    \item\textbf{crownBaseHeight:} Height from ground level where tree crown begins
                    \item\textbf{crownRadius:} Radius of tree crown
                    \item\textbf{crownHeight:} Height of tree crown 
                    \end{itemize}
                \end{itemize} 
\end{itemize}

\subsection{fdsOutput2Unity.py}
\label{PythonOutput2Unity}
Converts plot3D data from FDS into HDF5 data to be loaded into Unity
\begin{itemize}
    \item \textbf{Class instantiation}
    \begin{itemize}    
    \item Parameters   
        \begin{itemize}
        \item\textbf{fds\_output\_directory:}  Full path to where FDS data was output
        \item\textbf{fds\_input\_location:}  Full path to FDS input file
        \item\textbf{save\_location:} Full path to where data should be saved once processed
        \item\textbf{save\_type:} Allows for selection for output file type
.
        \end{itemize} 
    \end{itemize}
    
    \item \textbf{read\_in\_fds}
    \item[] Reads in FDS input file to generate list of data being saved as plot3D 
    
    \item \textbf{get\_file\_timestep}
    \item[] Extracts the timestep from the filename
      
    \item \textbf{group\_files\_by\_time}
    \item[]  Groups filenames by timestamp to allow for multi-mesh simulations
    
    \item \textbf{find\_max\_values\_parallel}
    \item[] Parallel function to find the maximum values for each time of plot3D data

    \item \textbf{get\_values}
    \item[] Calculates minimum and maximum values for all types of plot3D data


    \item \textbf{runParallel}
    \item[] Reads in and saves all plot3D data in parallel.

    \item \textbf{get\_mesh\_number}
    \item[] Pulls mesh number from filename

    \item \textbf{q\_file\_to\_dict}
    \item[] Reads in plot3D data and saves it to a dictionary to allow all threads to access the data when running in parallel 

    \item \textbf{write\_to\_json}
    \item[] Saves all data to JSON format
        \item[] \textbf{JSON File Structure}   
                \begin{itemize}
                \item\textbf{fire:} 2-D array, size: N {number of voxels}  by four
                \item[] [x, y, z, q] where x, y, and z represent the position while q represents the heat release rate
                \item\textbf{smoke:} 2-D array, size: N {number of voxels}  by four
                \item[] [x, y, z, q] where x, y, and z represent the position while q represents the smoke density
                \item\textbf{configData:}
                \begin{itemize}
                    \item\textbf{min:} 1-D Array, Minimum value for [fire, smoke]
                    \item\textbf{max:} 1-D Array, Maximum value for [fire, smoke]
                \end{itemize} 
    
                \end{itemize} 
    \item \textbf{write2bin}
    \item[] Saves all data in a custom binary format
            \item[] \textbf{Binary File Structure}   
                \begin{itemize}
                \item\textbf{Header}
                \item[] Five 32-bit integers corresponding to the length of each of the five scalar values from the plot3D output
                \item\textbf{ 2-D array with [x,y,z,q] as quantities, where x, y, and z represent the position while q represents the respective scalar value } 
                \item[] \textbf{Note:} this is a space matrix version of the output from plot3D files
                \end{itemize}
    \item \textbf{write\_to\_hdf5}
    \item[] Saves all data in HDF5 format
        \item[] \textbf{HDF5 File Structure}   
            \begin{itemize}
            \item\textbf{fire:} 2-D array, size: N {number of voxels}  by four
            \item[] [x, y, z, q] where x, y, and z represent the position while q represents the heat release rate
            \item\textbf{smoke:} 2-D array, size: N {number of voxels}  by four
            \item[] [x, y, z, q] where x, y, and z represent the position while q represents the smoke density
            \item\textbf{min:} 1-D Array, Minimum value for [fire, smoke]
            \item\textbf{max:} 1-D Array, Maximum value for [fire, smoke]
        \end{itemize} 
    \end{itemize}


\subsection{fdsPathLines.py}
\label{PythonPathLines}
Takes plot3D data and calculates the amount of turbulence (represented as reynolds numbers) to identify regions of interest. Then calculates pathlines that will intersect with points sampled from these regions
\begin{itemize}
    \item \textbf{Class instantiation}
    \begin{itemize}    
    \item Parameters   
        \begin{itemize}
        \item\textbf{directory:} Location of the FDS output files
        \item\textbf{fds\_input\_location:} Location of the FDS input file.
        \end{itemize} 
    \end{itemize}   
    
    \item \textbf{\_\_check\_valid\_file}
    \item[] Verifies file path is valid
    
    \item \textbf{\_\_set\_voxel\_size}
    \item[] Calculates voxel size
      
    \item \textbf{get\_position\_from\_index}
    \item[]  Converts index value into a 3-D position
    
    \item \textbf{\_\_set\_minimum\_pathline\_length}
    \item[] Sets the minimum length of pathlines

    \item \textbf{filter\_streams\_by\_length}
    \item[] Generates list of pathlines longer than minimum length

    \item \textbf{\_\_add\_ribbon\_points}
    \item[] Generates a set number of pathline starting points between two given points
    \begin{itemize}    
    \item Parameters   
        \begin{itemize}
        \item\textbf{starting\_point:} starting point for calculation
        \item\textbf{ending\_point:} ending point for calculation
        \item\textbf{number\_of\_points} total number of starting points to be calculated
        \end{itemize} 
    \end{itemize}   

    \item \textbf{run\_ode}
    \item[] Runs the ode solver for all saved starting points beginning at a specified timestep's index, can also run reverse integration
    \begin{itemize}    
    \item Parameters   
        \begin{itemize}
        \item\textbf{time\_step\_index:} indexed value of what timestep to start the ode solver from
        \item\textbf{reverse\_integration} A boolean that if set to true the ode solver will solve from designated timestep backwards until time is at zero
        \end{itemize} 
    \end{itemize}   

    \item \textbf{start\_ode}
    \item[] Calls run\_ode on all timesteps including reverse integration if needed 
    
    \begin{itemize}    
    \item Parameters   
        \begin{itemize}
        \item\textbf{reverse\_integration} A boolean that if set to true the ode solver will solve from designated timestep backwards until time is at zero
        \end{itemize} 
    \end{itemize}   
    
    
    \item \textbf{combine\_ode\_frames}
    \item[] Combines data frames from the forwards and backward integration
    
        \begin{itemize}    
        \item Parameters   
            \begin{itemize}
            \item\textbf{all\_forward\_data} Array of ode solver data frames 
            \item\textbf{all\_backwards\_data} Array of ode solver data frames
            \end{itemize} 
        \end{itemize}   


    \item \textbf{write\_hdf5}
    \item[] Saves all data in HDF5 format
    
    \item[] \textbf{HDF5 File Structure}   
        \begin{itemize}
        \item\textbf{maxValue:} Maximum magnitude of wind represented as a pathline in the current timestep
        \item\textbf{number\_of\_wind\_streams:} Number of pathlines visualized in the current timestep
        \item\textbf{length\_of\_wind\_streams:} Array the size of the number of wind streams indicating the number of line segments per pathline
        \item\textbf{windstream\_\{N\}:} 2-D array, size: N {length of current pathlines}  by five
        \item[] [Time, Velocity, x, y, z]
        \end{itemize} 

    
    \item \textbf{get\_velocity}
    \item[] Returns the magnitude of the wind vector at a set point and time
            \begin{itemize}    
        \item Parameters   
            \begin{itemize}
            \item\textbf{re\_time:} current time to be analyzed 
            \item\textbf{x:} 3-D array of position 
            \item[] [x, y, z]
            \end{itemize} 
        \end{itemize}   
    
    \item \textbf{get\_index\_values}
    \item[] Returns the vector field index of a set point
            \begin{itemize}    
        \item Parameters   
            \begin{itemize} 
            \item\textbf{x:} 3-D array of position 
            \item[] [x, y, z]
            \end{itemize} 
        \end{itemize}   
    
    \item \textbf{add\_reynolds\_number}
    \item[] Adds the reynolds number  to the ode solver data frame
    
    \item \textbf{\_\_add\_velocity\_to\_ode\_data\_frame}
    \item[] Adds the velocity to the ode solver data frame
    
    \item \textbf{draw\_stream\_lines}
    \item[] Uses matplotlib to draw pathlines for each timestep
    
    
    \item \textbf{\_\_get\_closest\_time\_step\_index}
    \item[] Takes any time value and returns the index value of the nearest plot3D file
    
    \item \textbf{\_\_get\_reynolds\_matrix}
    \item[] Returns a 3-D array of reynolds numbers for a specified timestep

    \item \textbf{\_\_get\_reynolds\_number}
    \item[] Returns a reynolds number for a specified timestep

    \item \textbf{get\_data\_from\_time}
    \item[] Returns a dataframe from the ode solver for a specified timestep 

    \item \textbf{\_\_get\_max\_re}
    \item[] Returns a maximum reynolds numbers from all dataframes

    \item \textbf{get\_average\_re\_over\_time}
    \item[] Returns a 3-D array of the mean reynolds number over a specified time range
    
    \item \textbf{get\_mean\_std}
    \item[] Calculates data ranges for histogram plots
    
    \item \textbf{\_\_plot\_points\_re\_range}
    \item[] Returns indices of all points that are within a set range of values
    
    \item \textbf{get\_starting\_positions}
    \item[] Uses k-means to cluster all points from \textbf{\_\_plot\_points\_re\_range} to calculate and return a list of centroids
    
    \item \textbf{get\_all\_starting\_points}
    \item[] Calls \textbf{get\_average\_re\_over\_time, get\_mean\_std, \_\_plot\_points\_re\_range,} then \textbf{get\_starting\_positions} to generate all starting points of interest for the ode solver for a set range of reynolds numbers
    
    \item \textbf{set\_turbulent\_laminar\_poi}
    \item[] Calls \textbf{get\_all\_starting\_points} for the ranges of laminar and turbulent flow then combines the data sets
    
    \item \textbf{set\_random\_distro\_poi}
    \item[] Generates a random set of starting points for the ode solver
    
    \item \textbf{set\_even\_distro\_poi}
    \item[] Generates an evenly distributed set of starting points for the ode solver

\end{itemize}
\pagebreak
\subsection{main.py}
\label{PythonMain}
Creates the proper file structure and ensures all functions save data into the proper location  
\begin{itemize}
    \item \textbf{main}
    \item[] Creates a file structure for Unity to read in, copies FDS input file, runs \textbf{fds2ComplexGeom.py, FdsPathLines.py,} then \textbf{fdsOutputToUnity.py} 
    
\end{itemize}
\break

\section{FDS2UnityVR}
Visualizes the data from \textbf{FDSPreUnityTool} in an immersive VR environment using Unity's Real-Time Development Platform    
\subsection{ConfigData.cs}
 Saves all information when transitioning from one scene to another 
\begin{itemize}
    \item \textbf{Awake} 
    \item[]Checks for any data gathered from the main menu scene and saves them to the correct variables

    \item \textbf{getFireSmokeOption} 
    \item[] Returns the selected option for fire, smoke, or none

    \item \textbf{setFireSmokeOption} 
    \item[] Sets an option for fire, smoke, or none


    \item \textbf{getLoadTrees}
    \item[] Returns the selected option for trees or none

    \item \textbf{setLoadTrees}
    \item[] Sets an option for trees or none

    \item \textbf{getWindOption}
    \item[] Returns the selected option for windlines, windvectors, or none

    \item \textbf{setWindOption} 
    \item[] Sets an option for  windlines, windvectors, or none
\end{itemize}

\subsection{hrrLoader.cs}
Loads in a color mapped and animated fire particle engine in each voxel per timestep
\begin{itemize}
    \item \textbf{Start}
    \item[] Creates a pointer to the particle engine that will be used for fire animation and saves all mesh data needed for scaling the size of the particles

    \item \textbf{LateUpdate} 
    \item[] Places all particle engines mapped to correct color relative to heat release rate
\end{itemize}
        
\subsection{MainMenu.cs}
 Verifies menu check boxes are selected and verifies fire and directory structure for input data
\begin{itemize}
    \item \textbf{ Start}
    \item[] Initializes progress bar

    \item \textbf{FireSmokeToggleChange}
    \item[] Saves list of what fire, smoke, or none option is selected
    
    \item \textbf{TreeToggleChange}
    \item[] Saves changes when tree option is toggled from on/off
    
    \item \textbf{WindToggleChange}
    \item[] Saves changes when tree option is changed from wind path, wind vector, or none
    
     
    \item \textbf{PlayGame}
    \item[] When play button is clicked it preloads the next scene as long as the directory input is valid
    
    \item \textbf{Update}
    \item[] Moves the loading bar as long as the next scene is loading

    \item \textbf{ UpdateDirTexField}
    \item[] Updates text field when VR keyboard is used


    \item \textbf{ FieldInput}
    \item[] Validates that all file types are in input directory
    
    \item \textbf{FileExists}
    \item[] Checks if files exist in specific directory 
\end{itemize}


\subsection{PauseMenu.cs}
Checks pause button input and tracks time in pause menu to allow for accurate timesteps after pausing 
\begin{itemize}
    \item \textbf{Start}
    \item[] Checks if pause option was preselected

    \item \textbf{ Update}
    \item[] If pause button is pressed, change timescale from zero to one or one to zero


    \item \textbf{updateTime}
    \item[] Tracks time inside of pause menu to keep accurate timing once it is unpaused
\end{itemize}

\subsection{smokeLoader.cs}
Loads in a color mapped and animated smoke particle engine in each voxel per timestep
\begin{itemize}
    \item \textbf{Start}
    \item[] Creates a pointer to the particle engine that will be used for fire animation and saves all mesh data needed for scaling the size of the particles

    \item \textbf{LateUpdate} 
    \item[] Places all particle engines mapped to correct color relative to heat release rate
\end{itemize}
    


\subsection{smvReader.cs}
Loads in and caches heat release rate and smoke density data while tracking the current timestep
\begin{itemize}
    \item\textbf{Start}
    \item[] Checks if fire, smoke, or none is selected, loads in binary file of sparse matrix data

    \item\textbf{getMeshData}
    \item[] Returns mesh data

    \item\textbf{sortedFileArray}
    \item[] Converts list of file paths to dictionary: where the keys are timesteps and the values are the file path
    

    \item\textbf{getFileTime}
    \item[] Parses file path to timestep
    
    \item\textbf{Update}
    \item[] Calls function to load in plot data
    
    \item\textbf{optimizedFDSLoader}
    \item[] Reads in smoke and fire data, saving to dictionaries to be accessed later
\end{itemize}

  
\subsection{TerrainBuilder.cs}
Loads a JSON of terrain data from fds2ComplexGeom.py \ref{PythonComplexGeom} and maps to a 3-D mesh with texturing
\begin{itemize}
    \item \textbf{Start}
    \item[] Builds smooth 3-D mesh or cubic terrain based on input settings

    \item\textbf{MovePlayer}
    \item[] Moves player to the highest point on the topography
    
    \item\textbf{buildTerrainCubes}
    \item[] Builds topography with cubes
    \item\textbf{ParseFds}
    \item[] Reads FDS input file to parse mesh data
    
    \item\textbf{GetVerts}
    \item[] Reads in vertices from JSON file saves to mesh and saves as UVs for texturing 
    
    \item\textbf{GetFaces}
    \item[] Reads in faces from JSON
\end{itemize}


\subsection{TreeLoader.cs}
Loads a JSON of tree data from  fds2ComplexGeom.py \ref{PythonComplexGeom} and maintains scale regardless of the size of the 3-D tree object        

\begin{itemize}
    \item \textbf{ Start}
    \item[] Checks if trees should be loaded, if so calls \textbf{fdsReader} function

    \item\textbf{fdsReader}
    \item[] Reads in tree data from JSON, places trees and scales them based on the size of the 3-D tree object to keep scale correct
\end{itemize}

\subsection{WindStreams.cs}
Loads in and caches pathline data from fdsPathLines.py \ref{PythonPathLines} to be visualized each timestep
\begin{itemize}
    \item \textbf{Start}
    \item[] Checks if windlines or windvectors will be visualized, if not script is deactivated, wind data is loaded into dictionary
    
    \item \textbf{GetFileTime}
    \item[] Parses file name to get timestep
    
    \item \textbf{SortedFileArray}
    \item[] Sorts list of file paths based on timestep
    
    \item \textbf{readInData}
    \item[] Reads in binary file data
    \item[] \textbf{Note:} This is a legacy function that is no longer used
    

    \item \textbf{loadNextWindLines}
    \item[] Loads in the new pathlines
    
    \item \textbf{loadNextWindVector}
    \item[] Loads in the new path vectors

    \item \textbf{setMaxVelovity}
    \item[] Updates maximum velocity value if needed
    
    \item \textbf{setMinVelovity}
    \item[] Updates minimum velocity value if needed
    
    \item \textbf{getMaxVelovity}
    \item[] Returns maximum velocity 

    \item \textbf{ readInData2Dict}
    \item[] Reads in binary file data
    \item[] \textbf{Note:} This is a legacy function that is no longer used
    

    \item \textbf{readInDataHDF5}
    \item[] Reads in all data from HDF5 files
    \item \textbf{Update}
    \item[] Checks if next timestep needs to be loaded in, if so it calls corresponding function based on menu selection 
\end{itemize}       